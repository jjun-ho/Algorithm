< 그리디 알고리즘(Greedy Algorithm) >
- 현재 상황에서 가장 좋아 보이는 답을 선택하는 방법
- 각 부분에서 최적을 선택하면 전체에서도 최적이 될 것이라는 가정을 전제로 한다
- 선택은 항상 하위 문제에 대한 해답이 나오기 전에 선택된다
- 눈 앞의 이익만 우선 추구하는 알고리즘
- 최적해를 찾을 수 없으면 최적해를 찾고, 최적해를 찾을 수 없으면 시간 내에 그런대로 괜찮을 해를 찾는 것이 목표
- 최적해를 구하기 어려운 문제들이 있는데, 그리디 알고리즘으로 그럭저럭 괜찮은 해를 구할 수 있음
---
< 이진 트리의 최적합 경로 찾기 >
- 각 노드의 값은 양수
- 바로 다음 자식 노드와 방문한 노드의 값만 알 수 있음
- 왼쪽/오른쪽 어느 쪽으로 분기할지 매 단계 결정해야 함
---
< 보따리 문제 >
- 부피 M의 보따리, n개의 물건
- x[i]: 물건 i 
- x[i].w: 물건 i의 부피
- x[i].p: 물건 i의 가치
- 물건들의 부피 합이 M을 넘지 않으면서 가치 합이 최대가 되도록 물건 넣기
---
< 동전 바꾸기 >
- 동전 종류: 500원, 100원, 50원, 10원, 5원, 1원
- 임의의 금액을 가장 적은 수의 동전으로 만들기
행- 동전의 상위 단위가 하위 단위의 배수: 그리디 알고리즘 -> 최적해 가능
- 그렇지 않으면 최적해 보장 안됨
–> 동전 종류: 500원, 400원, 100원, 75원, 50원
–> 그리디: 1,300원 = 500원 2개, 100원 3개: 총 5개
–> 최적해: 1,300원 = 500원 1개, 400원 2개: 총 3개
---
< 최적해가 보장되는 예 >
1. 최소 신장 트리
2. 회의실 배정
- n개의 회의 신청(시작/종료 시간)에 대한 회의실 스케줄링
- 시간이 겹치지 않으면서 가장 많은 수의 회의 수