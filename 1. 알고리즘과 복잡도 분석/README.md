< 알고리즘 >
- 어떤 작업을 수행하기 위해 입력을 받아 원하는 출력을 만들어 내는 과정을 기술한 것
- 입력 -> 출력으로 변화하는 계산 절차
- 해야 할 작업을 명확하게 기술 -> 입력과 출력을 명확하게 기술
---
< 점근적 표기법 (Asymptotic notation) >
 - 알고리즘의 효율성이 문제가 되는 것은 입력의 크기가 충분히 클 
---
< 세타(Theta) θ-표기법 (θ-notation) >
- Θ(𝑔(𝑛)) ={𝑓(𝑛)|∃𝑐1, 𝑐2, 𝑛0>0
𝑠.𝑡. 0 ≤ 𝑐1𝑔(𝑛) ≤ 𝑓(𝑛) ≤ 𝑐2𝑔(𝑛), ∀𝑛 ≥ 𝑛0}
- 상한과 하한이 존재
- c1g(n)과 c2g(n) 사이에 있는 함수 f(n)들의 집합
- 𝑓(𝑛) ∈ Θ(𝑛) ⟺ 𝑓(𝑛) = Θ(𝑛)
- Θ(𝑛^r): f(n)의 최고차항이 n^r 이면(계수 무시) f(n) =  Θ(𝑛^r)
---
< 빅오(Big-oh) O-표기법 (O-notation) >
- 𝑂(𝑔(𝑛)) = {𝑓(𝑛)|∃𝑐, 𝑛0 > 0 𝑠.𝑡. 0 ≤ 𝑓(𝑛) ≤ 𝑐𝑔(𝑛), ∀𝑛 ≥ 𝑛0}
- 상한만 존재
- Θ(g(𝑛)) ⊆ 𝑂(𝑔(𝑛))
- O(n^r): f(n)의 최고차항이 n^r 이하이면(계수 무시) f(n) = O(𝑛^r)
---
< 빅오메가(Big-omega) Ω-표기법 (Ω-notation) >
- Ω𝑔(𝑛) = {𝑓(𝑛)|∃𝑐, 𝑛0 > 0 𝑠.𝑡. 0 ≤ 𝑐𝑔(𝑛)  ≤ 𝑓(𝑛), ∀𝑛 ≥ 𝑛0}
- 하한만 존재
– Θ(𝑔(𝑛)) ⊆ Ω(𝑔(𝑛))
- Ω(𝑛^r): 𝑓(𝑛)의 최고차항이 𝑛^r 이상이면(계수 무시) 𝑓(𝑛) = Ω(𝑛^r)
---
< 리틀오(Little-oh) o-표기법 (o-notation)>
- 𝑜(𝑔(𝑛)) = {𝑓(𝑛)|∀𝑐 > 0, ∃𝑛0 > 0 𝑠.𝑡. 0 ≤ 𝑓(𝑛) < 𝑐𝑔(𝑛), ∀𝑛 ≥ 𝑛0}
- 𝑜(𝑔(𝑛)) = 𝑓(𝑛)의 최고차항 < 𝑔(𝑛)의 최고차항
- 𝑜(𝑛^r): 𝑓(𝑛)의 최고차항이 𝑛^r 미만이면 𝑓(𝑛) = 𝑜(𝑛^r)
---
< 리틀오메가(Little-omega) ω-표기법 (ω-notation) >
- 𝜔(𝑔(𝑛)) = {𝑓(𝑛)|∀𝑐 > 0, ∃𝑛0 > 0 𝑠.𝑡. 0 ≤ 𝑐𝑔(𝑛) < 𝑓(𝑛), ∀𝑛 ≥ 𝑛0}
- 𝑓(𝑛)의 최고차항 > 𝑔(𝑛)의 최소차항
- 𝜔(n^r): 𝑓(𝑛)의 최고차항이 𝑛^r 초과이면 𝑓(𝑛) = 𝜔(𝑛^r)
