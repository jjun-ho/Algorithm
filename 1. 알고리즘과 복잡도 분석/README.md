< 알고리즘 >
- 어떤 작업을 수행하기 위해 입력을 받아 원하는 출력을 만들어 내는 과정을 기술한 것
- 입력 -> 출력으로 변화하는 계산 절차
- 해야 할 작업을 명확하게 기술 -> 입력과 출력을 명확하게 기술
--- 
< 컴퓨터 알고리즘을 성명하기 위한 4단계 >
1. 문제 정의 (Problem definition)
2. 알고리즘 설명 (Algorithm description)
3. 정확성 증명 (Correctness proof) 
4. 성능 분석 (Performance analtsis)
---
< 점근적 표기법 (Asymptotic notation) >
- 알고리즘의 효율성이 문제가 되는 것은 입력의 크기가 충분히 클 때이므로, 
알고리즘의 성능분석은 공평한 비교를 위해 점근적 표기법에 의해 기술한다.
1. 세타(Theta) θ-표기법 (θ-notation)
2. 빅오(Big-oh) O-표기법 (O-notation)
3. 빅오메가(Big-omega) Ω-표기법 (Ω-notation)
4. 리틀오(Little-oh) o-표기법 (o-notation)
5. 리틀오메가(Little-omega) ω-표기법 (ω-notation)
---
< 세타(Theta) θ-표기법 (θ-notation) >
- Θ(𝑔(𝑛)) ={𝑓(𝑛)|∃𝑐1, 𝑐2, 𝑛0>0
𝑠.𝑡. 0 ≤ 𝑐1𝑔(𝑛) ≤ 𝑓(𝑛) ≤ 𝑐2𝑔(𝑛), ∀𝑛 ≥ 𝑛0}
- 상한과 하한이 존재
- c1g(n)과 c2g(n) 사이에 있는 함수 f(n)들의 집합
- 𝑓(𝑛) ∈ Θ(𝑛) ⟺ 𝑓(𝑛) = Θ(𝑛)
- Θ(𝑛^r): f(n)의 최고차항이 n^r 이면(계수 무시) f(n) =  Θ(𝑛^r)
---
< 빅오(Big-oh) O-표기법 (O-notation) >
- 𝑂(𝑔(𝑛)) = {𝑓(𝑛)|∃𝑐, 𝑛0 > 0 𝑠.𝑡. 0 ≤ 𝑓(𝑛) ≤ 𝑐𝑔(𝑛), ∀𝑛 ≥ 𝑛0}
- 상한만 존재
- Θ(g(𝑛)) ⊆ 𝑂(𝑔(𝑛))
- O(n^r): f(n)의 최고차항이 n^r 이하이면(계수 무시) f(n) = O(𝑛^r)
---
< 빅오메가(Big-omega) Ω-표기법 (Ω-notation) >
- Ω𝑔(𝑛) = {𝑓(𝑛)|∃𝑐, 𝑛0 > 0 𝑠.𝑡. 0 ≤ 𝑐𝑔(𝑛)  ≤ 𝑓(𝑛), ∀𝑛 ≥ 𝑛0}
- 하한만 존재
– Θ(𝑔(𝑛)) ⊆ Ω(𝑔(𝑛))
- Ω(𝑛^r): 𝑓(𝑛)의 최고차항이 𝑛^r 이상이면(계수 무시) 𝑓(𝑛) = Ω(𝑛^r)
---
< 리틀오(Little-oh) o-표기법 (o-notation) >
- 𝑜(𝑔(𝑛)) = {𝑓(𝑛)|∀𝑐 > 0, ∃𝑛0 > 0 𝑠.𝑡. 0 ≤ 𝑓(𝑛) < 𝑐𝑔(𝑛), ∀𝑛 ≥ 𝑛0}
- 𝑜(𝑔(𝑛)) = 𝑓(𝑛)의 최고차항 < 𝑔(𝑛)의 최고차항
- 𝑜(𝑛^r): 𝑓(𝑛)의 최고차항이 𝑛^r 미만이면 𝑓(𝑛) = 𝑜(𝑛^r)
---
< 리틀오메가(Little-omega) ω-표기법 (ω-notation) >
- 𝜔(𝑔(𝑛)) = {𝑓(𝑛)|∀𝑐 > 0, ∃𝑛0 > 0 𝑠.𝑡. 0 ≤ 𝑐𝑔(𝑛) < 𝑓(𝑛), ∀𝑛 ≥ 𝑛0}
- 𝑓(𝑛)의 최고차항 > 𝑔(𝑛)의 최고차항
- 𝜔(n^r): 𝑓(𝑛)의 최고차항이 𝑛^r 초과이면 𝑓(𝑛) = 𝜔(𝑛^r)
---
---
< 점화식 >
- 어떤 함수를 자신과 똑같은 함수를 이용해 나타내는 것
- 수열에서 인접한 항들 사이에 관계식

ex)
- 등차수열의 점화식 𝑎n = 𝑎n-1 + 2
- 𝑛!의 점화식 𝑓(𝑛) =𝑛𝑓(𝑛−1)
- 피보나치 수열의 점화식 𝑓(𝑛) = 𝑓(𝑛−1) +𝑓(𝑛−2)
---
<점화식의 점근적 분석 방법>
1. 반복 대치
> 반복해서 집어 넣는다.
2. 추정 후 증명 
> 추정을 한 뒤, 경계조건과 귀납적 가정과 전개를 하여 증명한다.
3. 마스터 정리
> >특정한 모양을 가진 재귀식  
> 𝑇(𝑛) = 𝑎𝑇(𝑛/𝑏) + 𝑓 (𝑛)
> 
> h(𝑛) =𝑛^logba 라고 할 때, 양의 상수 𝜀에대해
> 1. f(n)/h(n) = O(1/n^𝜀) 이면 𝑇(𝑛) = Θ(h(𝑛))
> 2. f(n)/h(n) = Ω(n^𝜀) 이고 어떤 상수 𝑐(<1)와 충분히 큰 모든 𝑛에 대하여 𝑎𝑓(n/b) ≤ 𝑐𝑓(𝑛) 이면 𝑇(𝑛) = Θ(𝑓(𝑛))
> 3. f(n)/h(n) = Θ(1) (상수 시간) 이면 𝑇(𝑛) = Θ(h(𝑛)log𝑛)

> * 마스터 정리의 근사 버전
> 
> h(𝑛) =𝑛^logba 라고 할 때,
> 1. h(n)이 f(n)을 압도하면, 𝑇(𝑛) = Θ(h(𝑛))
> 2. f(n)이 h(n)을 압도하고 충분히 큰 모든 n에 대하여 𝑎𝑓(n/b) ≤ 𝑐𝑓(𝑛) 이면  𝑇(𝑛) = Θ(𝑓(𝑛))
> 3. f(n)/h(n) = Θ(1) (상수 시간) 이면 𝑇(𝑛) = Θ(h(𝑛)log𝑛)
---
