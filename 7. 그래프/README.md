 < 그래프 >
- 정점 (Vertex)
- 간선  (Edge)
- 가중치 (Weight)


- 무향 그래프 (Undirected Graph)
- 유향 그래프 (Directed Graph)
---
< 그래프 표현: 인접 행렬 >
- 정점의 개수 n -> n*n 행렬
- n*n 행렬 필요
- n^2의 공간
- n^2의 시간
- 산선의 밀도가 낮으면(간선의 개수 적으면) 비효율:
> 0이 대부분
---
< 그래프 표현: 인접 리스트>
- 연결 리스트 사용
- 간선의 밀도가 높으면 비효율:
> 연결 리스트 오버헤드  
> 
> 간선 여부 확인을 위해 연결 리스트를 훑어야 함(최약의 경우 n번)
---
< 그래프 표현: 인접 배열 >
- 각 정점에 연결된 정점들을 연결 리스트 대신 배열로
- 배열을 정렬된 형태로 구성 -> 이진 탐색 가능
- 간섭 여부 확인을 위한 비교 횟수:
> 인접한 정점 개수가 k개이면 (1+logk)번 이내의 비교
---
< 그래프 표현: 인접 해시 테이블 >
- 각 인접 배열을 해시 테이블로 구성
- 테이블 크기를 배열 크기의 2배로 하요 적재율을 0.5로 하면 평균 2번 이내의 비교
- 임의의 두 정점이 인접한지 확인하는 경우에는 좋음
- 어떤 정점에서 인접 정점들을 차례로 훑어야 하는 경우에는 좋지 않음
---
< 탐색 >
- 너비 우선 탐색 (Breadth-First Search: BFS): 거리 우선
- 깊이 우선 탐색 (Depth-First Search: DFS): 순서 우선
--- 
< 최소 신장 트리(Minimum Spanning Tree) >
- 그래프 G = (V,E)의 신장 트리:

> 정점 집합 V는 그대로
> 
> 간선을 |V|-1 개만 남겨서 트리로 만든 것

- 최소 신장 트리

> 간선 가중치 합이 가장 작은 트리
---
< 프림 알고리즘(Prim Algorithm) >
- 공집합에서 시작하여 V가 될 때까지 키워 나간다
- 정점을 하나 추가할 때마다 간선을 하나 확장
- 수행 시간: O(E*logV)
---
< 크루스칼 알고리즘(Kruskal Algorithm) >
- 사이클을 만들지 않는 최소 비용 간선을 하나씩 추가
- 수행 시간: O(E*logV)
---
< 다익스트라 알고리즘(Dijkstra Algorithm) >
- 최단경로문제를 해결하는 다익스트라 알고리즘 정점을 하나씩 추가하면서 완화를 통해 새로운 경로에서 경로값을 계산하여 새로운 경로를 추가하여 최단 경로를 찾는 알고리즘
- 하나의 시작점에서 하나의 도착점을 가는 최단경로를 찾는 알고리즘
- 가중치가 있는 유향 그래프
- 간선이 음의 값을 가져서는 안된다.
- 산선의 가충치가 모두 0 이상
- 단일 시작점 최단 경로
- 수행 시간: O(E*logV)  
- 종료 조건이 없다면 하나의 시작점에서 모든 지점까지의 최단 거리를 찾는다.
- 너무 많이 탐색한다는 단점이 있다(벽이 없는 넓은 광야에서 전체 다 탐색)
---
< 벨만-포드 알고리즘(Bellman-Ford Algorithm) >
- 하나의 시작점에서 하나의 도착점을 가는 최단경로를 찾는 알고리즘
- 가중치가 있는 유향 그래프
- 간선의 가중치 음수 허용
- 단일 시작점 최단 경로
- 수행 시간: O(VE)
- 가중치 합이 음수인 사이클 X: 이동할 때마다 누적 가중치 값 작아짐
---
< 모든 쌍 최단 경로 알고리즘 >
- 모든 정점 간의 최단 경로
- d(m; i,j) 최대 m개의 간선을 사용한 정점 i -> j의 최단 거리
- d(m; i,j) = W(i,j) (if. m=1)
            = min(1<=k<=n){d(m-1; i,k) + W(k,j) (if. m>=2)
- 수행 시간: 0(n^4)
---
< 플로이드-워샬 알고리즘(Floyd-Warshall) >
- d(k; i,j): 정점 집합 {1,2,...,k}에 속하는 정점들만 거치는 정점 i -> j의 최단 거리
- d(k; i,j) = w(i,j) (if. k=0)
            = min{d(k-1; i,j), d(k-1; i,k)+d(k-1; k,j)} (if. k>=1)
- 수행 시간: 0(n^3)
---
< DAG(Directed Acyclic Graph) >
- 사이클이 없는 유향 그래프
- 모던 정점을 한 줄로 늘어놓았을 때 뒤의 정점에서 앞의 정점으로 가는 간선은 없도록 하는 정점의 순열이 존재함
-> 위상 정렬로 얻을 수 있음
- 위상 정렬을 사용하여 최단경로를 구한다
- 수행 시간: 0(V+E)
---
< 강연결 요소(Strongly Connected Component) >
- 모든 두 정점이 양방향으로 서로에게 이르는 경로 존재
-> "그래프 G가 강하게 연결되었다"라고 함
- 강연결 요소: 그래프에서 강하게 연결된 부분 그래프
- 수행 시간: 0(V+E)
---