 < 그래프 >
- 정점 (Vertex)
- 간선  (Edge)
- 가중치 (Weight)
  

- 무향 그래프 (Undirected Graph)
- 유향 그래프 (Directed Graph)

---
< 그래프 표현: 인접 행렬 >
- 정점의 개수 n -> n*n 행렬
- n*n 행렬 필요
- n^2의 공간
- n^2의 시간
- 산선의 밀도가 낮으면(간선의 개수 적으면) 비효율:
> 0이 대부분

---
< 그래프 표현: 인접 리스트>
- 연결 리스트 사용
- 간선의 밀도가 높으면 비효율:
> 연결 리스트 오버헤드  
> 
> 간선 여부 확인을 위해 연결 리스트를 훑어야 함(최약의 경우 n번)

---
< 그래프 표현: 인접 배열 >
- 각 정점에 연결된 정점들을 연결 리스트 대신 배열로
- 배열을 정렬된 형태로 구성 -> 이진 탐색 가능
- 간섭 여부 확인을 위한 비교 횟수:
> 인접한 정점 개수가 k개이면 (1+logk)번 이내의 비교

---
< 그래프 표현: 인접 해시 테이블 >
- 각 인접 배열을 해시 테이블로 구성
- 테이블 크기를 배열 크기의 2배로 하요 적재율을 0.5로 하면 평균 2번 이내의 비교
- 임의의 두 정점이 인접한지 확인하는 경우에는 좋음
- 어떤 정점에서 인접 정점들을 차례로 훑어야 하는 경우에는 좋지 않음

---
< 탐색 >
- 너비 우선 탐색 (Breadth-First Search: BFS): 거리 우선
- 깊이 우선 탐색 (Depth-First Search: DFS): 순서 우선

--- 
< 최소 신장 트리(Minimum Spanning Tree) >
- 그래프 G = (V,E)의 신장 트리:

> 정점 집합 V는 그대로
> 
> 간선을 |V|-1 개만 남겨서 트리로 만든 것

- 최소 신장 트리

> 간선 가중치 합이 가장 작은 트리

---
< 프림 알고리즘(Prim Algorithm) >
- 공집합에서 시작하여 V가 될 때까지 키워 나간다
- 정점을 하나 추가할 때마다 간선을 하나 확장
- 수행 시간: O(E*logV)  

---
< 크루스칼 알고리즘(Kruskal Algorithm) >
- 사이클을 만들지 않는 최소 비용 간선을 하나씩 추가
- 수행 시간: O(E*logV) 