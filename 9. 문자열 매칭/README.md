< 원시적인 매칭 방법 >
- 문자열 A[]이 문자열 P[]을 포함하고 있는지 확인
- n: 문자열 A의 길이
- m: 문자열 P의 길이
- m << n으로 가정
- A[1...m], A[2...m+1], A[3...m+2] ... 방식으로 최대 n-m+1번 비교
- 수행 시간: O(mn)
---
< 오토마타를 이용힌 매칭 >
- 오토마타 Q, q0, 𝐹, Σ, 𝛿
> Q: 상태들의 집합
> 
> q0: 시작 상태
> 
> 𝐹: 목표 상태들의 집합
> 
> Σ: 입력 가능한 문자 집합 
>
> 𝛿: 상태 전이 함수
- 수행 시간: Θ(𝑛 + |Σ||𝑄|) <- Θ(탐색시간 + 상태전이(행렬) 만드는 시간)
- 개선 사항
> 패턴 p의 문자들 + 기타로 행렬 구성
> 인덱스 변환 테이블 i[]: 𝛿(𝑠,𝑟) -> 𝛿(𝑠,𝑖[𝑟])
---
< 라빈-카프(Rabin-Karp) 알고리즘 >
- 문자열 패턴을 수치로 전환: 문자열 비교̀ -> 수치 비교
- 패턴 P를 수치화
- 문자열 A의 길이 m부분 문자열 수치화
- 개선
- a{i} = d(a{i-1} - (d^(m-1)) * A[i-1]) + A[i+m-1]
-> d: 진수, n: A의 길이, m: P의 길이
- 한계점: a{i}가 매우 큰 수가 될 수 있음 -> 오버플로우 -> 모듈러 연산
---
< 보이어-무어-호스풀(Boyer-Moore-Horspool) 알고리즘 >
- A[i...i+m]와 P[1...m] 비교
–> 비교하는 A[]의 마지막 문자가 P[]에 없다면 비교하는 A[] 각각의 문자로 시작하는 문자열은 P[1...m]과 매치되지 않는다.
-> m개 문자만큼 점프
---
< KMP(Knuth, Morris, Pratt) 알고리즘 >

---

