m = [[0,0,0,0,0,0],
     [0,3,2,5,7,1],
     [0,9,3,3,5,9],
     [0,1,4,9,2,1],
     [0,1,2,6,6,3],
     [0,9,7,5,1,3]]

# 각 배열마다 도착하는 최고 점수 계산값 저장하는 변수 c 선언
c = [[0,0,0,0,0,0],
     [0,0,0,0,0,0],
     [0,0,0,0,0,0],
     [0,0,0,0,0,0],
     [0,0,0,0,0,0],
     [0,0,0,0,0,0]]

def Matrix_Path_1(i,j):  # 정사각형 격자에 대해 구현
    if i == 0 or j == 0 :
        return 0
    return m[i][j] + max(Matrix_Path_1(i-1,j), Matrix_Path_1(i,j-1))

def Matrix_Path_2(n):
    for i in range(n+1):    # j가 0인 경우
        c[i][0] = 0
    for j in range(1,n+1):  # i가 0인 경우
        c[0][j] = 0
    for i in range(1,n+1):
        for j in range(1, n+1):
            c[i][j] = m[i][j] + max(c[i-1][j], c[1][j-1])
    return c[n][n]

"""
* 핼렬 경로 문제
- 오른쪽이나 아래쪽으로만 이동 가능
- 가장 왼쪽 위에서 가장 오른쪽 아래로 이동하면서 만나는 칸의 합이 가장 큰 경로 찾기
- (i,j)에 도착하기 직전: (i-1,j) or (i,j-1)
- (i,j)에 도착하는 최고 점수 C = max{(i-1,j)까지의 최고점수, (i,j-1)까지의 최고점수} + (i,j)의 점수
- C = 0 (if. i=0 or j=o)
    = M(ij) + max{C(i-1,j). C(i,j-1)} (if. otherwise
"""